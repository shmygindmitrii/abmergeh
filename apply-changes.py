import argparse
import subprocess
import re
import shutil
import time
from dataclasses import dataclass
from pathlib import Path


SECTION_ADDED = "ADDED"
SECTION_MODIFIED = "MODIFIED"
SECTION_DELETED = "DELETED"


class ProgressTracker:
    def __init__(self, total: int) -> None:
        self.total = total
        self.enabled = total > 0
        self.start_monotonic = time.monotonic()
        self.processed = 0
        self.last_percent = -1

        if self.enabled:
            print(f"Total entries to process: {self.total}")

    def step(self) -> None:
        if not self.enabled:
            return

        self.processed += 1
        percent = int((self.processed / self.total) * 100)
        if percent == self.last_percent:
            return

        self.last_percent = percent
        elapsed = time.monotonic() - self.start_monotonic
        per_item = elapsed / self.processed if self.processed else 0.0
        remaining = max(self.total - self.processed, 0)
        eta_seconds = int(per_item * remaining)
        print(
            f"Progress: {percent}% ({self.processed}/{self.total}), ETA: {eta_seconds}s"
        )


def parse_changes_file(changes_path: Path) -> dict[str, list[str]]:
    """Parse output generated by get-changes.py into file lists."""
    result = {
        SECTION_ADDED: [],
        SECTION_MODIFIED: [],
        SECTION_DELETED: [],
    }

    current_section = None
    with changes_path.open("r", encoding="utf-8") as f:
        for raw_line in f:
            line = raw_line.strip()
            if not line:
                continue

            # Ignore any comment line.
            if line.startswith("//"):
                continue

            # Main section markers, e.g. [ADDED]: 2
            if line.startswith("[") and "]:" in line:
                section_name = line[1:].split("]:", 1)[0].strip()
                if section_name in result:
                    current_section = section_name
                # ignore extension buckets and unknown sections
                continue

            if current_section in (SECTION_ADDED, SECTION_MODIFIED, SECTION_DELETED):
                if ":" not in line:
                    continue
                rel_path = line.split(":", 1)[0].strip()
                if rel_path:
                    result[current_section].append(rel_path)

    return result


def parse_commit_dominance_config(config_path: Path) -> set["CommitDominanceRule"]:
    """Parse text config lines like '<winner_commit> > <loser_commit>'."""
    rules: set[CommitDominanceRule] = set()
    with config_path.open("r", encoding="utf-8") as config_file:
        for line_number, raw_line in enumerate(config_file, start=1):
            line = raw_line.strip()
            if not line or line.startswith("#") or line.startswith("//"):
                continue

            if ">" not in line:
                raise ValueError(
                    "Invalid commit dominance config line "
                    f"{line_number}: expected '<winner_commit> > <loser_commit>'"
                )

            winner, loser = [part.strip() for part in line.split(">", maxsplit=1)]
            if not winner or not loser:
                raise ValueError(
                    "Invalid commit dominance config line "
                    f"{line_number}: winner and loser commits must be non-empty"
                )

            rules.add(CommitDominanceRule(winner_commit=winner, loser_commit=loser))

    return rules


def copy_from_new(rel_path: str, old_root: Path, new_root: Path) -> None:
    src = new_root / rel_path
    dst = old_root / rel_path

    if not src.exists() or not src.is_file():
        raise FileNotFoundError(f"Source file does not exist in new_dir: {src}")

    dst.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dst)


@dataclass
class ModifyDecision:
    rel_path: str
    should_copy: bool
    reason: str | None = None
    old_file_description: str | None = None
    new_file_description: str | None = None


@dataclass
class InformationalSkip:
    rel_path: str
    reason: str
    old_file_description: str
    new_file_description: str


@dataclass
class FileCommitDescription:
    commit_hash: str
    commit_date: str
    description: str


@dataclass(frozen=True)
class CommitDominanceRule:
    winner_commit: str
    loser_commit: str


@dataclass
class ManualResolutionLogEntry:
    rel_path: str
    winner_commit: str
    loser_commit: str
    action: str
    reason: str


@dataclass
class GitHistoryInfo:
    is_git_repo: bool
    file_commit_timestamps: dict[str, int]
    added_never_modified_files: set[str]


@dataclass
class RepoMetadata:
    root: Path
    is_git_repo: bool
    description_cache: dict[str, FileCommitDescription | None]


def build_repo_metadata(repo_root: Path) -> RepoMetadata:
    repo_check = subprocess.run(
        ["git", "-C", repo_root.as_posix(), "rev-parse", "--is-inside-work-tree"],
        capture_output=True,
        text=True,
        check=False,
    )
    is_git_repo = repo_check.returncode == 0 and repo_check.stdout.strip().lower() == "true"

    description_cache: dict[str, FileCommitDescription | None] = {}
    if is_git_repo:
        description_cache = collect_recent_file_descriptions(repo_root)

    return RepoMetadata(root=repo_root, is_git_repo=is_git_repo, description_cache=description_cache)


def collect_recent_file_descriptions(repo_root: Path) -> dict[str, FileCommitDescription | None]:
    """Collect last first-parent commit date/subject per file.

    Only commits on the mainline of HEAD are considered (no side-branch history).
    """
    toplevel_result = subprocess.run(
        ["git", "-C", repo_root.as_posix(), "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True,
        check=False,
    )
    if toplevel_result.returncode != 0:
        return {}

    repo_top_level = Path(toplevel_result.stdout.strip()).resolve()
    try:
        path_prefix = repo_root.resolve().relative_to(repo_top_level)
        path_prefix_str = path_prefix.as_posix()
        if path_prefix_str == ".":
            path_prefix_str = ""
    except ValueError:
        path_prefix_str = ""

    def normalize_log_path(log_path: str) -> str | None:
        rel = Path(log_path).as_posix()
        if not path_prefix_str:
            return rel
        prefix = f"{path_prefix_str}/"
        if rel == path_prefix_str:
            return ""
        if rel.startswith(prefix):
            return rel[len(prefix) :]
        return None

    result = subprocess.run(
        [
            "git",
            "-C",
            repo_root.as_posix(),
            "log",
            "--first-parent",
            "--reverse",
            "--name-only",
            "--date=format:%Y-%m-%d %H:%M:%S %z",
            "--pretty=format:__COMMIT__%n%H%n%ad%n%s",
            "--diff-filter=AM",
            "HEAD",
        ],
        capture_output=True,
        text=True,
        check=False,
    )
    if result.returncode != 0:
        return {}

    descriptions: dict[str, FileCommitDescription | None] = {}
    current_commit_hash: str | None = None
    current_commit_date: str | None = None
    current_commit_subject: str | None = None

    for raw_line in result.stdout.splitlines():
        line = raw_line.strip()
        if not line:
            continue

        if line == "__COMMIT__":
            current_commit_hash = None
            current_commit_date = None
            current_commit_subject = None
            continue

        if current_commit_hash is None:
            current_commit_hash = line
            continue

        if current_commit_date is None:
            current_commit_date = line
            continue

        if current_commit_subject is None:
            current_commit_subject = line
            continue

        normalized_path = normalize_log_path(line)
        if not normalized_path:
            continue

        # --reverse walks from oldest to newest, so overwrite to keep newest mainline commit.
        descriptions[normalized_path] = FileCommitDescription(
            commit_hash=current_commit_hash,
            commit_date=current_commit_date,
            description=current_commit_subject,
        )

    return descriptions


def get_file_description(repo: RepoMetadata, rel_path: str) -> FileCommitDescription | None:
    if rel_path in repo.description_cache:
        return repo.description_cache[rel_path]

    if not repo.is_git_repo:
        repo.description_cache[rel_path] = None
        return None

    result = subprocess.run(
        [
            "git",
            "-C",
            repo.root.as_posix(),
            "log",
            "--first-parent",
            "-1",
            "--date=format:%Y-%m-%d %H:%M:%S %z",
            "--format=%H%n%ad%n%s",
            "--",
            rel_path,
        ],
        capture_output=True,
        text=True,
        check=False,
    )
    if result.returncode != 0:
        repo.description_cache[rel_path] = None
        return None

    lines = [line.strip() for line in result.stdout.splitlines() if line.strip()]
    if len(lines) < 3:
        repo.description_cache[rel_path] = None
        return None

    description = FileCommitDescription(commit_hash=lines[0], commit_date=lines[1], description=lines[2])
    repo.description_cache[rel_path] = description
    return description


def collect_git_history_info(repo_root: Path) -> GitHistoryInfo:
    """Collect per-file commit timestamps and files that were added but never modified."""
    repo_check = subprocess.run(
        ["git", "-C", repo_root.as_posix(), "rev-parse", "--is-inside-work-tree"],
        capture_output=True,
        text=True,
        check=False,
    )
    if repo_check.returncode != 0 or repo_check.stdout.strip().lower() != "true":
        return GitHistoryInfo(
            is_git_repo=False,
            file_commit_timestamps={},
            added_never_modified_files=set(),
        )

    toplevel_result = subprocess.run(
        ["git", "-C", repo_root.as_posix(), "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True,
        check=True,
    )
    repo_top_level = Path(toplevel_result.stdout.strip()).resolve()
    try:
        path_prefix = repo_root.resolve().relative_to(repo_top_level)
        path_prefix_str = path_prefix.as_posix()
        if path_prefix_str == ".":
            path_prefix_str = ""
    except ValueError:
        path_prefix_str = ""

    def normalize_log_path(log_path: str) -> str | None:
        """Convert git-log path (repo-root relative) to repo_root-relative path."""
        rel = Path(log_path).as_posix()
        if not path_prefix_str:
            return rel
        prefix = f"{path_prefix_str}/"
        if rel == path_prefix_str:
            return ""
        if rel.startswith(prefix):
            return rel[len(prefix) :]
        return None

    log_cmd = [
        "git",
        "-C",
        repo_root.as_posix(),
        "log",
        "--first-parent",
        "--reverse",
        "--name-only",
        "--pretty=format:__COMMIT__ %ct",
        "--diff-filter=AM",
        "HEAD",
    ]
    log_result = subprocess.run(log_cmd, capture_output=True, text=True, check=True)

    file_commit_timestamps: dict[str, int] = {}
    current_timestamp: int | None = None
    for raw_line in log_result.stdout.splitlines():
        line = raw_line.strip()
        if not line:
            continue
        if line.startswith("__COMMIT__ "):
            current_timestamp = int(line.split(maxsplit=1)[1])
            continue

        if current_timestamp is None:
            continue
        normalized_line = normalize_log_path(line)
        if not normalized_line:
            continue

        # --reverse walks from oldest to newest, so overwrite to keep newest mainline timestamp.
        file_commit_timestamps[normalized_line] = current_timestamp

    status_log_result = subprocess.run(
        [
            "git",
            "-C",
            repo_root.as_posix(),
            "log",
            "--first-parent",
            "--name-status",
            "--pretty=format:__COMMIT__",
            "--diff-filter=AM",
            "HEAD",
        ],
        capture_output=True,
        text=True,
        check=True,
    )

    all_added_files: set[str] = set()
    all_modified_files: set[str] = set()
    for raw_line in status_log_result.stdout.splitlines():
        line = raw_line.strip()
        if not line:
            continue
        if line.startswith("__COMMIT__"):
            continue
        parts = line.split("\t", 1)
        if len(parts) != 2:
            continue
        status, rel_path = parts
        normalized_path = normalize_log_path(rel_path)
        if not normalized_path:
            continue
        if status == "A":
            all_added_files.add(normalized_path)
        elif status == "M":
            all_modified_files.add(normalized_path)

    added_never_modified_files = all_added_files - all_modified_files

    return GitHistoryInfo(
        is_git_repo=True,
        file_commit_timestamps=file_commit_timestamps,
        added_never_modified_files=added_never_modified_files,
    )


def decide_modified_copy(
    rel_path: str,
    old_root: Path,
    new_root: Path,
    added_never_modified_files: set[str],
    allow_never_modified_replace: bool,
    old_repo_meta: RepoMetadata,
    new_repo_meta: RepoMetadata,
    commit_dominance_rules: set[CommitDominanceRule],
) -> tuple[ModifyDecision, ManualResolutionLogEntry | None]:
    """Allow replacing MODIFIED file by mtime, with optional manual commit dominance."""
    src = new_root / rel_path
    dst = old_root / rel_path

    if not src.exists() or not src.is_file():
        return (
            ModifyDecision(
                rel_path=rel_path,
                should_copy=False,
                reason=f"missing source in new_dir: {src.as_posix()}",
                old_file_description=format_file_description(old_repo_meta, rel_path),
                new_file_description=format_file_description(new_repo_meta, rel_path),
            ),
            None,
        )
    if not dst.exists() or not dst.is_file():
        return (
            ModifyDecision(
                rel_path=rel_path,
                should_copy=False,
                reason=f"missing destination in old_dir: {dst.as_posix()}",
                old_file_description=format_file_description(old_repo_meta, rel_path),
                new_file_description=format_file_description(new_repo_meta, rel_path),
            ),
            None,
        )

    src_mtime = src.stat().st_mtime
    dst_mtime = dst.stat().st_mtime
    if src_mtime >= dst_mtime:
        return ModifyDecision(rel_path=rel_path, should_copy=True), None

    old_file_description = get_file_description(old_repo_meta, rel_path)
    new_file_description = get_file_description(new_repo_meta, rel_path)

    if old_file_description is not None and new_file_description is not None:
        old_commit = old_file_description.commit_hash
        new_commit = new_file_description.commit_hash
        new_wins = CommitDominanceRule(winner_commit=new_commit, loser_commit=old_commit)
        old_wins = CommitDominanceRule(winner_commit=old_commit, loser_commit=new_commit)
        if new_wins in commit_dominance_rules:
            return (
                ModifyDecision(
                    rel_path=rel_path,
                    should_copy=True,
                    reason=(
                        "copied by manual commit dominance override: "
                        f"{new_commit} > {old_commit}"
                    ),
                ),
                ManualResolutionLogEntry(
                    rel_path=rel_path,
                    winner_commit=new_commit,
                    loser_commit=old_commit,
                    action="copied-from-new",
                    reason="manual commit dominance override",
                ),
            )

        if old_wins in commit_dominance_rules:
            return (
                ModifyDecision(
                    rel_path=rel_path,
                    should_copy=False,
                    reason=(
                        "kept old_dir by manual commit dominance override: "
                        f"{old_commit} > {new_commit}"
                    ),
                    old_file_description=format_file_description(old_repo_meta, rel_path),
                    new_file_description=format_file_description(new_repo_meta, rel_path),
                ),
                ManualResolutionLogEntry(
                    rel_path=rel_path,
                    winner_commit=old_commit,
                    loser_commit=new_commit,
                    action="kept-old",
                    reason="manual commit dominance override",
                ),
            )

    if allow_never_modified_replace and rel_path in added_never_modified_files:
        return (
            ModifyDecision(
                rel_path=rel_path,
                should_copy=True,
                reason=(
                    "copied because file was added and never modified in git history, and "
                    "--allow-never-modified-replace is enabled"
                ),
            ),
            None,
        )

    return (
        ModifyDecision(
            rel_path=rel_path,
            should_copy=False,
            reason=(
                "old_dir file is newer "
                f"(old mtime={dst_mtime:.6f}, new mtime={src_mtime:.6f})"
            ),
            old_file_description=format_file_description(old_repo_meta, rel_path),
            new_file_description=format_file_description(new_repo_meta, rel_path),
        ),
        None,
    )


def format_file_description(repo: RepoMetadata, rel_path: str) -> str:
    description = get_file_description(repo, rel_path)
    if description is None:
        if repo.is_git_repo:
            return "git metadata unavailable for file"
        return "directory is not a git repository"

    return (
        f"{description.commit_hash} | {description.commit_date} | "
        f"{description.description}"
    )


def render_conflicts(conflicts: list[ModifyDecision]) -> str:
    lines = ["MODIFIED conflicts (old_dir file is newer or file is missing):"]
    for conflict in conflicts:
        lines.append(f"- {conflict.rel_path}: {conflict.reason}")
        lines.append(f"  old_dir: {conflict.old_file_description}")
        lines.append(f"  new_dir: {conflict.new_file_description}")
    return "\n".join(lines)


def render_informational_skips(skips: list[InformationalSkip]) -> str:
    lines = [
        "MODIFIED informational skips (new_dir file is added-and-never-modified and does not override old_dir):"
    ]
    for skip in skips:
        lines.append(f"- {skip.rel_path}: {skip.reason}")
        lines.append(f"  old_dir: {skip.old_file_description}")
        lines.append(f"  new_dir: {skip.new_file_description}")
    return "\n".join(lines)


def render_manual_resolution_log(entries: list[ManualResolutionLogEntry]) -> str:
    lines = ["Manual commit dominance resolutions:"]
    for entry in entries:
        lines.append(
            f"- {entry.rel_path}: {entry.action} ({entry.winner_commit} > {entry.loser_commit})"
        )
        lines.append(f"  reason: {entry.reason}")
    return "\n".join(lines)


def delete_in_old(rel_path: str, old_root: Path) -> None:
    target = old_root / rel_path
    if target.exists() and target.is_file():
        target.unlink()


def should_process_path(rel_path: str, include_extensions: set[str] | None) -> bool:
    if include_extensions is None:
        return True

    suffix = Path(rel_path).suffix.lower()
    if suffix.startswith("."):
        suffix = suffix[1:]

    return suffix in include_extensions


def matches_patterns(rel_path: str, patterns: list[str] | None) -> bool:
    """Return True if rel_path matches at least one pattern.

    Supported pattern formats:
    - Glob (default), e.g. ``src/**`` or ``*.py``
    - Regex with ``re:`` prefix, e.g. ``re:^src/.+\.py$``

    When no patterns are provided, everything matches.
    """
    if not patterns:
        return True

    path = Path(rel_path)
    for pattern in patterns:
        if pattern.startswith("re:"):
            regex = pattern[3:]
            try:
                if re.search(regex, rel_path):
                    return True
            except re.error as exc:
                raise ValueError(f"Invalid regex pattern '{pattern}': {exc}") from exc
        elif path.match(pattern):
            return True

    return False


def should_apply_for_action(
    rel_path: str,
    include_extensions: set[str] | None,
    include_patterns: list[str] | None,
    exclude_patterns: list[str] | None,
) -> bool:
    """Combine extension and path filters for a single file path."""
    if not should_process_path(rel_path, include_extensions):
        return False
    if not matches_patterns(rel_path, include_patterns):
        return False
    if exclude_patterns and matches_patterns(rel_path, exclude_patterns):
        return False
    return True


def apply_changes(
    old_dir: Path,
    new_dir: Path,
    changes_file: Path,
    include_extensions: set[str] | None,
    apply_added: bool,
    apply_modified: bool,
    apply_deleted: bool,
    add_include_patterns: list[str] | None,
    add_exclude_patterns: list[str] | None,
    delete_include_patterns: list[str] | None,
    delete_exclude_patterns: list[str] | None,
    conflicts_output_file: Path | None,
    informational_skips_output_file: Path | None,
    manual_resolution_output_file: Path | None,
    added_never_modified_files: set[str],
    new_added_never_modified_files: set[str],
    allow_never_modified_replace: bool,
    old_repo_meta: RepoMetadata,
    new_repo_meta: RepoMetadata,
    commit_dominance_rules: set[CommitDominanceRule],
) -> None:
    changes = parse_changes_file(changes_file)

    total_entries = 0
    if apply_added:
        total_entries += len(changes[SECTION_ADDED])
    if apply_modified:
        total_entries += len(changes[SECTION_MODIFIED])
    if apply_deleted:
        total_entries += len(changes[SECTION_DELETED])

    progress = ProgressTracker(total_entries)

    added = 0
    modified = 0
    deleted = 0
    conflicts: list[ModifyDecision] = []
    informational_skips: list[InformationalSkip] = []
    manual_resolution_logs: list[ManualResolutionLogEntry] = []

    if apply_added:
        for rel_path in changes[SECTION_ADDED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                add_include_patterns,
                add_exclude_patterns,
            ):
                progress.step()
                continue
            copy_from_new(rel_path, old_dir, new_dir)
            added += 1
            progress.step()

    if apply_modified:
        for rel_path in changes[SECTION_MODIFIED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                add_include_patterns,
                add_exclude_patterns,
            ):
                progress.step()
                continue
            decision, manual_log_entry = decide_modified_copy(
                rel_path,
                old_dir,
                new_dir,
                added_never_modified_files,
                allow_never_modified_replace,
                old_repo_meta,
                new_repo_meta,
                commit_dominance_rules,
            )
            if manual_log_entry is not None:
                manual_resolution_logs.append(manual_log_entry)

            if decision.should_copy:
                copy_from_new(rel_path, old_dir, new_dir)
                modified += 1
            else:
                if rel_path in new_added_never_modified_files:
                    informational_skips.append(
                        InformationalSkip(
                            rel_path=rel_path,
                            reason=(
                                "skipped without conflict because new_dir file was added and never "
                                "modified in git history"
                            ),
                            old_file_description=decision.old_file_description
                            or format_file_description(old_repo_meta, rel_path),
                            new_file_description=decision.new_file_description
                            or format_file_description(new_repo_meta, rel_path),
                        )
                    )
                else:
                    conflicts.append(decision)
            progress.step()

    if apply_deleted:
        for rel_path in changes[SECTION_DELETED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                delete_include_patterns,
                delete_exclude_patterns,
            ):
                progress.step()
                continue
            delete_in_old(rel_path, old_dir)
            deleted += 1
            progress.step()

    print(
        f"Changes were applied from '{changes_file.as_posix()}': "
        f"added {added} file(s), modified {modified} file(s), deleted {deleted} file(s)"
    )

    if conflicts:
        conflict_text = render_conflicts(conflicts)
        print(conflict_text)
        if conflicts_output_file:
            conflicts_output_file.parent.mkdir(parents=True, exist_ok=True)
            conflicts_output_file.write_text(conflict_text + "\n", encoding="utf-8")
            print(f"Conflicts were written to: {conflicts_output_file.as_posix()}")

    if informational_skips:
        informational_text = render_informational_skips(informational_skips)
        print(informational_text)
        if informational_skips_output_file:
            informational_skips_output_file.parent.mkdir(parents=True, exist_ok=True)
            informational_skips_output_file.write_text(
                informational_text + "\n", encoding="utf-8"
            )
            print(
                "Informational skips were written to: "
                f"{informational_skips_output_file.as_posix()}"
            )

    if manual_resolution_logs:
        manual_resolution_text = render_manual_resolution_log(manual_resolution_logs)
        print(manual_resolution_text)
        if manual_resolution_output_file:
            manual_resolution_output_file.parent.mkdir(parents=True, exist_ok=True)
            manual_resolution_output_file.write_text(
                manual_resolution_text + "\n", encoding="utf-8"
            )
            print(
                "Manual dominance resolutions were written to: "
                f"{manual_resolution_output_file.as_posix()}"
            )



def main() -> None:
    parser = argparse.ArgumentParser(
        description=(
            "Apply changes from a get-changes.py log. Supports applying only "
            "added/modified/deleted changes and filtering by extension or path patterns "
            "(glob by default, regex via re:...)."
        )
    )
    parser.add_argument("old_dir", help="Directory to update")
    parser.add_argument("new_dir", help="Directory used as source for new/modified files")
    parser.add_argument("changes_file", help="Path to text output produced by get-changes.py")
    parser.add_argument(
        "--extensions",
        nargs="+",
        help="Process only listed extensions, e.g. --extensions py json md",
    )
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument(
        "--only-add",
        action="store_true",
        help="Apply only files listed in [ADDED] section",
    )
    mode_group.add_argument(
        "--only-delete",
        action="store_true",
        help="Apply only files listed in [DELETED] section",
    )
    mode_group.add_argument(
        "--only-modified",
        action="store_true",
        help="Apply only files listed in [MODIFIED] section",
    )
    parser.add_argument(
        "--add-include",
        nargs="+",
        help=(
            "Patterns to include for ADDED files. Glob by default, "
            "regex with re: prefix (e.g. re:^src/.+\\.py$)."
        ),
    )
    parser.add_argument(
        "--add-exclude",
        nargs="+",
        help="Patterns to exclude for ADDED files (glob or re:regex)",
    )
    parser.add_argument(
        "--delete-include",
        nargs="+",
        help="Patterns to include for DELETED files (glob or re:regex)",
    )
    parser.add_argument(
        "--delete-exclude",
        nargs="+",
        help="Patterns to exclude for DELETED files (glob or re:regex)",
    )
    parser.add_argument(
        "--conflicts-out",
        help="Optional output file path for MODIFIED conflicts list",
    )
    parser.add_argument(
        "--informational-skips-out",
        help=(
            "Optional output file path for MODIFIED entries skipped because new_dir files "
            "were added and never modified"
        ),
    )
    parser.add_argument(
        "--commit-dominance-config",
        help=(
            "Optional text config file with manual commit dominance rules in format "
            "'<winner_commit> > <loser_commit>'"
        ),
    )
    parser.add_argument(
        "--manual-resolution-log-out",
        help="Optional output file path for applied manual commit dominance resolutions",
    )
    parser.add_argument(
        "--allow-never-modified-replace",
        action="store_true",
        help=(
            "Allow replacing MODIFIED files that were added and never modified "
            "in old_dir git history even if new_dir file has older mtime."
        ),
    )
    args = parser.parse_args()

    old_root = Path(args.old_dir).resolve()
    new_root = Path(args.new_dir).resolve()
    changes_path = Path(args.changes_file).resolve()

    if not old_root.exists() or not old_root.is_dir():
        raise SystemExit(f"old_dir does not exist or is not a directory: {old_root}")
    if not new_root.exists() or not new_root.is_dir():
        raise SystemExit(f"new_dir does not exist or is not a directory: {new_root}")
    if not changes_path.exists() or not changes_path.is_file():
        raise SystemExit(f"changes_file does not exist or is not a file: {changes_path}")

    include_extensions = None
    if args.extensions:
        include_extensions = {ext.lower().lstrip(".") for ext in args.extensions}

    apply_added = not args.only_delete and not args.only_modified
    apply_modified = not args.only_add and not args.only_delete
    apply_deleted = not args.only_add and not args.only_modified

    git_history_info = collect_git_history_info(old_root)
    new_git_history_info = collect_git_history_info(new_root)
    if git_history_info.is_git_repo:
        print(
            "Git history metadata loaded: "
            f"{len(git_history_info.file_commit_timestamps)} file(s) with commit timestamps, "
            f"{len(git_history_info.added_never_modified_files)} file(s) added and never modified"
        )
    else:
        print("old_dir is not a git repository; proceeding without git history metadata")

    if not new_git_history_info.is_git_repo:
        print("new_dir is not a git repository; informational skip detection is disabled")

    commit_dominance_rules: set[CommitDominanceRule] = set()
    if args.commit_dominance_config:
        config_path = Path(args.commit_dominance_config).resolve()
        if not config_path.exists() or not config_path.is_file():
            raise SystemExit(
                "commit dominance config does not exist or is not a file: "
                f"{config_path.as_posix()}"
            )
        try:
            commit_dominance_rules = parse_commit_dominance_config(config_path)
        except ValueError as exc:
            raise SystemExit(f"Invalid commit dominance config: {exc}") from exc

        print(
            "Loaded manual commit dominance rules: "
            f"{len(commit_dominance_rules)} from {config_path.as_posix()}"
        )

    apply_changes(
        old_root,
        new_root,
        changes_path,
        include_extensions,
        apply_added,
        apply_modified,
        apply_deleted,
        args.add_include,
        args.add_exclude,
        args.delete_include,
        args.delete_exclude,
        Path(args.conflicts_out).resolve() if args.conflicts_out else None,
        Path(args.informational_skips_out).resolve() if args.informational_skips_out else None,
        Path(args.manual_resolution_log_out).resolve() if args.manual_resolution_log_out else None,
        git_history_info.added_never_modified_files,
        new_git_history_info.added_never_modified_files,
        args.allow_never_modified_replace,
        build_repo_metadata(old_root),
        build_repo_metadata(new_root),
        commit_dominance_rules,
    )
    print("Changes were applied successfully.")


if __name__ == "__main__":
    main()
