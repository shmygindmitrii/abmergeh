import argparse
import subprocess
import re
import shutil
import time
from dataclasses import dataclass
from pathlib import Path


SECTION_ADDED = "ADDED"
SECTION_MODIFIED = "MODIFIED"
SECTION_DELETED = "DELETED"


class ProgressTracker:
    def __init__(self, total: int) -> None:
        self.total = total
        self.enabled = total > 0
        self.start_monotonic = time.monotonic()
        self.processed = 0
        self.last_percent = -1

        if self.enabled:
            print(f"Total entries to process: {self.total}")

    def step(self) -> None:
        if not self.enabled:
            return

        self.processed += 1
        percent = int((self.processed / self.total) * 100)
        if percent == self.last_percent:
            return

        self.last_percent = percent
        elapsed = time.monotonic() - self.start_monotonic
        per_item = elapsed / self.processed if self.processed else 0.0
        remaining = max(self.total - self.processed, 0)
        eta_seconds = int(per_item * remaining)
        print(
            f"Progress: {percent}% ({self.processed}/{self.total}), ETA: {eta_seconds}s"
        )


def parse_changes_file(changes_path: Path) -> dict[str, list[str]]:
    """Parse output generated by get-changes.py into file lists."""
    result = {
        SECTION_ADDED: [],
        SECTION_MODIFIED: [],
        SECTION_DELETED: [],
    }

    current_section = None
    with changes_path.open("r", encoding="utf-8") as f:
        for raw_line in f:
            line = raw_line.strip()
            if not line:
                continue

            # Ignore any comment line.
            if line.startswith("//"):
                continue

            # Main section markers, e.g. [ADDED]: 2
            if line.startswith("[") and "]:" in line:
                section_name = line[1:].split("]:", 1)[0].strip()
                if section_name in result:
                    current_section = section_name
                # ignore extension buckets and unknown sections
                continue

            if current_section in (SECTION_ADDED, SECTION_MODIFIED, SECTION_DELETED):
                if ":" not in line:
                    continue
                rel_path = line.split(":", 1)[0].strip()
                if rel_path:
                    result[current_section].append(rel_path)

    return result


def copy_from_new(rel_path: str, old_root: Path, new_root: Path) -> None:
    src = new_root / rel_path
    dst = old_root / rel_path

    if not src.exists() or not src.is_file():
        raise FileNotFoundError(f"Source file does not exist in new_dir: {src}")

    dst.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dst)


@dataclass
class ModifyDecision:
    rel_path: str
    should_copy: bool
    reason: str | None = None


@dataclass
class GitHistoryInfo:
    file_commit_timestamps: dict[str, int]
    first_commit_added_files: set[str]


def collect_git_history_info(repo_root: Path) -> GitHistoryInfo:
    """Collect per-file commit timestamps and files added in the first commit."""
    repo_check = subprocess.run(
        ["git", "-C", repo_root.as_posix(), "rev-parse", "--is-inside-work-tree"],
        capture_output=True,
        text=True,
        check=False,
    )
    if repo_check.returncode != 0 or repo_check.stdout.strip().lower() != "true":
        raise ValueError(f"old_dir is not a git repository: {repo_root.as_posix()}")

    log_cmd = [
        "git",
        "-C",
        repo_root.as_posix(),
        "log",
        "--name-only",
        "--pretty=format:__COMMIT__ %ct",
        "--diff-filter=AM",
        "HEAD",
    ]
    log_result = subprocess.run(log_cmd, capture_output=True, text=True, check=True)

    file_commit_timestamps: dict[str, int] = {}
    current_timestamp: int | None = None
    for raw_line in log_result.stdout.splitlines():
        line = raw_line.strip()
        if not line:
            continue
        if line.startswith("__COMMIT__ "):
            current_timestamp = int(line.split(maxsplit=1)[1])
            continue

        if current_timestamp is None:
            continue
        # git outputs the newest commit first; keep first seen timestamp.
        file_commit_timestamps.setdefault(line, current_timestamp)

    first_commit_result = subprocess.run(
        ["git", "-C", repo_root.as_posix(), "rev-list", "--max-parents=0", "HEAD"],
        capture_output=True,
        text=True,
        check=True,
    )
    first_commit_hashes = [h for h in first_commit_result.stdout.splitlines() if h.strip()]
    if not first_commit_hashes:
        raise ValueError("Unable to resolve first commit for repository")
    first_commit = first_commit_hashes[0]

    first_commit_files_result = subprocess.run(
        [
            "git",
            "-C",
            repo_root.as_posix(),
            "show",
            "--pretty=format:",
            "--name-status",
            first_commit,
        ],
        capture_output=True,
        text=True,
        check=True,
    )

    first_commit_added_files: set[str] = set()
    for raw_line in first_commit_files_result.stdout.splitlines():
        line = raw_line.strip()
        if not line:
            continue
        parts = line.split("\t", 1)
        if len(parts) != 2:
            continue
        status, rel_path = parts
        if status == "A":
            first_commit_added_files.add(rel_path)

    return GitHistoryInfo(
        file_commit_timestamps=file_commit_timestamps,
        first_commit_added_files=first_commit_added_files,
    )


def decide_modified_copy(
    rel_path: str,
    old_root: Path,
    new_root: Path,
    first_commit_added_files: set[str],
    allow_first_commit_added_replace: bool,
) -> ModifyDecision:
    """Allow replacing MODIFIED file only when new_root has newer content by mtime."""
    src = new_root / rel_path
    dst = old_root / rel_path

    if not src.exists() or not src.is_file():
        return ModifyDecision(
            rel_path=rel_path,
            should_copy=False,
            reason=f"missing source in new_dir: {src.as_posix()}",
        )
    if not dst.exists() or not dst.is_file():
        return ModifyDecision(
            rel_path=rel_path,
            should_copy=False,
            reason=f"missing destination in old_dir: {dst.as_posix()}",
        )

    src_mtime = src.stat().st_mtime
    dst_mtime = dst.stat().st_mtime
    if src_mtime >= dst_mtime:
        return ModifyDecision(rel_path=rel_path, should_copy=True)

    if allow_first_commit_added_replace and rel_path in first_commit_added_files:
        return ModifyDecision(
            rel_path=rel_path,
            should_copy=True,
            reason=(
                "copied because file was added in the first commit and "
                "--allow-first-commit-added-replace is enabled"
            ),
        )

    return ModifyDecision(
        rel_path=rel_path,
        should_copy=False,
        reason=(
            "old_dir file is newer "
            f"(old mtime={dst_mtime:.6f}, new mtime={src_mtime:.6f})"
        ),
    )


def render_conflicts(conflicts: list[ModifyDecision]) -> str:
    lines = ["MODIFIED conflicts (old_dir file is newer or file is missing):"]
    for conflict in conflicts:
        lines.append(f"- {conflict.rel_path}: {conflict.reason}")
    return "\n".join(lines)


def delete_in_old(rel_path: str, old_root: Path) -> None:
    target = old_root / rel_path
    if target.exists() and target.is_file():
        target.unlink()


def should_process_path(rel_path: str, include_extensions: set[str] | None) -> bool:
    if include_extensions is None:
        return True

    suffix = Path(rel_path).suffix.lower()
    if suffix.startswith("."):
        suffix = suffix[1:]

    return suffix in include_extensions


def matches_patterns(rel_path: str, patterns: list[str] | None) -> bool:
    """Return True if rel_path matches at least one pattern.

    Supported pattern formats:
    - Glob (default), e.g. ``src/**`` or ``*.py``
    - Regex with ``re:`` prefix, e.g. ``re:^src/.+\.py$``

    When no patterns are provided, everything matches.
    """
    if not patterns:
        return True

    path = Path(rel_path)
    for pattern in patterns:
        if pattern.startswith("re:"):
            regex = pattern[3:]
            try:
                if re.search(regex, rel_path):
                    return True
            except re.error as exc:
                raise ValueError(f"Invalid regex pattern '{pattern}': {exc}") from exc
        elif path.match(pattern):
            return True

    return False


def should_apply_for_action(
    rel_path: str,
    include_extensions: set[str] | None,
    include_patterns: list[str] | None,
    exclude_patterns: list[str] | None,
) -> bool:
    """Combine extension and path filters for a single file path."""
    if not should_process_path(rel_path, include_extensions):
        return False
    if not matches_patterns(rel_path, include_patterns):
        return False
    if exclude_patterns and matches_patterns(rel_path, exclude_patterns):
        return False
    return True


def apply_changes(
    old_dir: Path,
    new_dir: Path,
    changes_file: Path,
    include_extensions: set[str] | None,
    apply_added: bool,
    apply_modified: bool,
    apply_deleted: bool,
    add_include_patterns: list[str] | None,
    add_exclude_patterns: list[str] | None,
    delete_include_patterns: list[str] | None,
    delete_exclude_patterns: list[str] | None,
    conflicts_output_file: Path | None,
    first_commit_added_files: set[str],
    allow_first_commit_added_replace: bool,
) -> None:
    changes = parse_changes_file(changes_file)

    total_entries = 0
    if apply_added:
        total_entries += len(changes[SECTION_ADDED])
    if apply_modified:
        total_entries += len(changes[SECTION_MODIFIED])
    if apply_deleted:
        total_entries += len(changes[SECTION_DELETED])

    progress = ProgressTracker(total_entries)

    added = 0
    modified = 0
    deleted = 0
    conflicts: list[ModifyDecision] = []

    if apply_added:
        for rel_path in changes[SECTION_ADDED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                add_include_patterns,
                add_exclude_patterns,
            ):
                progress.step()
                continue
            copy_from_new(rel_path, old_dir, new_dir)
            added += 1
            progress.step()

    if apply_modified:
        for rel_path in changes[SECTION_MODIFIED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                add_include_patterns,
                add_exclude_patterns,
            ):
                progress.step()
                continue
            decision = decide_modified_copy(
                rel_path,
                old_dir,
                new_dir,
                first_commit_added_files,
                allow_first_commit_added_replace,
            )
            if decision.should_copy:
                copy_from_new(rel_path, old_dir, new_dir)
                modified += 1
            else:
                conflicts.append(decision)
            progress.step()

    if apply_deleted:
        for rel_path in changes[SECTION_DELETED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                delete_include_patterns,
                delete_exclude_patterns,
            ):
                progress.step()
                continue
            delete_in_old(rel_path, old_dir)
            deleted += 1
            progress.step()

    print(
        f"Changes were applied from '{changes_file.as_posix()}': "
        f"added {added} file(s), modified {modified} file(s), deleted {deleted} file(s)"
    )

    if conflicts:
        conflict_text = render_conflicts(conflicts)
        print(conflict_text)
        if conflicts_output_file:
            conflicts_output_file.parent.mkdir(parents=True, exist_ok=True)
            conflicts_output_file.write_text(conflict_text + "\n", encoding="utf-8")
            print(f"Conflicts were written to: {conflicts_output_file.as_posix()}")


def main() -> None:
    parser = argparse.ArgumentParser(
        description=(
            "Apply changes from a get-changes.py log. Supports applying only "
            "added/modified/deleted changes and filtering by extension or path patterns "
            "(glob by default, regex via re:...)."
        )
    )
    parser.add_argument("old_dir", help="Directory to update")
    parser.add_argument("new_dir", help="Directory used as source for new/modified files")
    parser.add_argument("changes_file", help="Path to text output produced by get-changes.py")
    parser.add_argument(
        "--extensions",
        nargs="+",
        help="Process only listed extensions, e.g. --extensions py json md",
    )
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument(
        "--only-add",
        action="store_true",
        help="Apply only files listed in [ADDED] section",
    )
    mode_group.add_argument(
        "--only-delete",
        action="store_true",
        help="Apply only files listed in [DELETED] section",
    )
    mode_group.add_argument(
        "--only-modified",
        action="store_true",
        help="Apply only files listed in [MODIFIED] section",
    )
    parser.add_argument(
        "--add-include",
        nargs="+",
        help=(
            "Patterns to include for ADDED files. Glob by default, "
            "regex with re: prefix (e.g. re:^src/.+\\.py$)."
        ),
    )
    parser.add_argument(
        "--add-exclude",
        nargs="+",
        help="Patterns to exclude for ADDED files (glob or re:regex)",
    )
    parser.add_argument(
        "--delete-include",
        nargs="+",
        help="Patterns to include for DELETED files (glob or re:regex)",
    )
    parser.add_argument(
        "--delete-exclude",
        nargs="+",
        help="Patterns to exclude for DELETED files (glob or re:regex)",
    )
    parser.add_argument(
        "--conflicts-out",
        help="Optional output file path for MODIFIED conflicts list",
    )
    parser.add_argument(
        "--allow-first-commit-added-replace",
        action="store_true",
        help=(
            "Allow replacing MODIFIED files that were added in the first commit "
            "of old_dir even if new_dir file has older mtime."
        ),
    )
    args = parser.parse_args()

    old_root = Path(args.old_dir).resolve()
    new_root = Path(args.new_dir).resolve()
    changes_path = Path(args.changes_file).resolve()

    if not old_root.exists() or not old_root.is_dir():
        raise SystemExit(f"old_dir does not exist or is not a directory: {old_root}")
    if not new_root.exists() or not new_root.is_dir():
        raise SystemExit(f"new_dir does not exist or is not a directory: {new_root}")
    if not changes_path.exists() or not changes_path.is_file():
        raise SystemExit(f"changes_file does not exist or is not a file: {changes_path}")

    include_extensions = None
    if args.extensions:
        include_extensions = {ext.lower().lstrip(".") for ext in args.extensions}

    apply_added = not args.only_delete and not args.only_modified
    apply_modified = not args.only_add and not args.only_delete
    apply_deleted = not args.only_add and not args.only_modified

    git_history_info = collect_git_history_info(old_root)
    print(
        "Git history metadata loaded: "
        f"{len(git_history_info.file_commit_timestamps)} file(s) with commit timestamps, "
        f"{len(git_history_info.first_commit_added_files)} file(s) added in first commit"
    )

    apply_changes(
        old_root,
        new_root,
        changes_path,
        include_extensions,
        apply_added,
        apply_modified,
        apply_deleted,
        args.add_include,
        args.add_exclude,
        args.delete_include,
        args.delete_exclude,
        Path(args.conflicts_out).resolve() if args.conflicts_out else None,
        git_history_info.first_commit_added_files,
        args.allow_first_commit_added_replace,
    )
    print("Changes were applied successfully.")


if __name__ == "__main__":
    main()
