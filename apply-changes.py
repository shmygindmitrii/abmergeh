import argparse
import re
import shutil
from dataclasses import dataclass
from pathlib import Path


SECTION_ADDED = "ADDED"
SECTION_MODIFIED = "MODIFIED"
SECTION_DELETED = "DELETED"


def parse_changes_file(changes_path: Path) -> dict[str, list[str]]:
    """Parse output generated by get-changes.py into file lists."""
    result = {
        SECTION_ADDED: [],
        SECTION_MODIFIED: [],
        SECTION_DELETED: [],
    }

    current_section = None
    with changes_path.open("r", encoding="utf-8") as f:
        for raw_line in f:
            line = raw_line.strip()
            if not line:
                continue

            # Ignore any comment line.
            if line.startswith("//"):
                continue

            # Main section markers, e.g. [ADDED]: 2
            if line.startswith("[") and "]:" in line:
                section_name = line[1:].split("]:", 1)[0].strip()
                if section_name in result:
                    current_section = section_name
                # ignore extension buckets and unknown sections
                continue

            if current_section in (SECTION_ADDED, SECTION_MODIFIED, SECTION_DELETED):
                if ":" not in line:
                    continue
                rel_path = line.split(":", 1)[0].strip()
                if rel_path:
                    result[current_section].append(rel_path)

    return result


def copy_from_new(rel_path: str, old_root: Path, new_root: Path) -> None:
    src = new_root / rel_path
    dst = old_root / rel_path

    if not src.exists() or not src.is_file():
        raise FileNotFoundError(f"Source file does not exist in new_dir: {src}")

    dst.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dst)


@dataclass
class ModifyDecision:
    rel_path: str
    should_copy: bool
    reason: str | None = None


def decide_modified_copy(rel_path: str, old_root: Path, new_root: Path) -> ModifyDecision:
    """Allow replacing MODIFIED file only when new_root has newer content by mtime."""
    src = new_root / rel_path
    dst = old_root / rel_path

    if not src.exists() or not src.is_file():
        return ModifyDecision(
            rel_path=rel_path,
            should_copy=False,
            reason=f"missing source in new_dir: {src.as_posix()}",
        )
    if not dst.exists() or not dst.is_file():
        return ModifyDecision(
            rel_path=rel_path,
            should_copy=False,
            reason=f"missing destination in old_dir: {dst.as_posix()}",
        )

    src_mtime = src.stat().st_mtime
    dst_mtime = dst.stat().st_mtime
    if src_mtime >= dst_mtime:
        return ModifyDecision(rel_path=rel_path, should_copy=True)

    return ModifyDecision(
        rel_path=rel_path,
        should_copy=False,
        reason=(
            "old_dir file is newer "
            f"(old mtime={dst_mtime:.6f}, new mtime={src_mtime:.6f})"
        ),
    )


def render_conflicts(conflicts: list[ModifyDecision]) -> str:
    lines = ["MODIFIED conflicts (old_dir file is newer or file is missing):"]
    for conflict in conflicts:
        lines.append(f"- {conflict.rel_path}: {conflict.reason}")
    return "\n".join(lines)


def delete_in_old(rel_path: str, old_root: Path) -> None:
    target = old_root / rel_path
    if target.exists() and target.is_file():
        target.unlink()


def should_process_path(rel_path: str, include_extensions: set[str] | None) -> bool:
    if include_extensions is None:
        return True

    suffix = Path(rel_path).suffix.lower()
    if suffix.startswith("."):
        suffix = suffix[1:]

    return suffix in include_extensions


def matches_patterns(rel_path: str, patterns: list[str] | None) -> bool:
    """Return True if rel_path matches at least one pattern.

    Supported pattern formats:
    - Glob (default), e.g. ``src/**`` or ``*.py``
    - Regex with ``re:`` prefix, e.g. ``re:^src/.+\.py$``

    When no patterns are provided, everything matches.
    """
    if not patterns:
        return True

    path = Path(rel_path)
    for pattern in patterns:
        if pattern.startswith("re:"):
            regex = pattern[3:]
            try:
                if re.search(regex, rel_path):
                    return True
            except re.error as exc:
                raise ValueError(f"Invalid regex pattern '{pattern}': {exc}") from exc
        elif path.match(pattern):
            return True

    return False


def should_apply_for_action(
    rel_path: str,
    include_extensions: set[str] | None,
    include_patterns: list[str] | None,
    exclude_patterns: list[str] | None,
) -> bool:
    """Combine extension and path filters for a single file path."""
    if not should_process_path(rel_path, include_extensions):
        return False
    if not matches_patterns(rel_path, include_patterns):
        return False
    if exclude_patterns and matches_patterns(rel_path, exclude_patterns):
        return False
    return True


def apply_changes(
    old_dir: Path,
    new_dir: Path,
    changes_file: Path,
    include_extensions: set[str] | None,
    apply_added: bool,
    apply_modified: bool,
    apply_deleted: bool,
    add_include_patterns: list[str] | None,
    add_exclude_patterns: list[str] | None,
    delete_include_patterns: list[str] | None,
    delete_exclude_patterns: list[str] | None,
    conflicts_output_file: Path | None,
) -> None:
    changes = parse_changes_file(changes_file)

    added = 0
    modified = 0
    deleted = 0
    conflicts: list[ModifyDecision] = []

    if apply_added:
        for rel_path in changes[SECTION_ADDED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                add_include_patterns,
                add_exclude_patterns,
            ):
                continue
            copy_from_new(rel_path, old_dir, new_dir)
            added += 1

    if apply_modified:
        for rel_path in changes[SECTION_MODIFIED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                add_include_patterns,
                add_exclude_patterns,
            ):
                continue
            decision = decide_modified_copy(rel_path, old_dir, new_dir)
            if decision.should_copy:
                copy_from_new(rel_path, old_dir, new_dir)
                modified += 1
            else:
                conflicts.append(decision)

    if apply_deleted:
        for rel_path in changes[SECTION_DELETED]:
            if not should_apply_for_action(
                rel_path,
                include_extensions,
                delete_include_patterns,
                delete_exclude_patterns,
            ):
                continue
            delete_in_old(rel_path, old_dir)
            deleted += 1
    
    print(
        f"Changes were applied from '{changes_file.as_posix()}': "
        f"added {added} file(s), modified {modified} file(s), deleted {deleted} file(s)"
    )

    if conflicts:
        conflict_text = render_conflicts(conflicts)
        print(conflict_text)
        if conflicts_output_file:
            conflicts_output_file.parent.mkdir(parents=True, exist_ok=True)
            conflicts_output_file.write_text(conflict_text + "\n", encoding="utf-8")
            print(f"Conflicts were written to: {conflicts_output_file.as_posix()}")


def main() -> None:
    parser = argparse.ArgumentParser(
        description=(
            "Apply changes from a get-changes.py log. Supports applying only "
            "added/modified/deleted changes and filtering by extension or path patterns "
            "(glob by default, regex via re:...)."
        )
    )
    parser.add_argument("old_dir", help="Directory to update")
    parser.add_argument("new_dir", help="Directory used as source for new/modified files")
    parser.add_argument("changes_file", help="Path to text output produced by get-changes.py")
    parser.add_argument(
        "--extensions",
        nargs="+",
        help="Process only listed extensions, e.g. --extensions py json md",
    )
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument(
        "--only-add",
        action="store_true",
        help="Apply only files listed in [ADDED] section",
    )
    mode_group.add_argument(
        "--only-delete",
        action="store_true",
        help="Apply only files listed in [DELETED] section",
    )
    mode_group.add_argument(
        "--only-modified",
        action="store_true",
        help="Apply only files listed in [MODIFIED] section",
    )
    parser.add_argument(
        "--add-include",
        nargs="+",
        help=(
            "Patterns to include for ADDED files. Glob by default, "
            "regex with re: prefix (e.g. re:^src/.+\\.py$)."
        ),
    )
    parser.add_argument(
        "--add-exclude",
        nargs="+",
        help="Patterns to exclude for ADDED files (glob or re:regex)",
    )
    parser.add_argument(
        "--delete-include",
        nargs="+",
        help="Patterns to include for DELETED files (glob or re:regex)",
    )
    parser.add_argument(
        "--delete-exclude",
        nargs="+",
        help="Patterns to exclude for DELETED files (glob or re:regex)",
    )
    parser.add_argument(
        "--conflicts-out",
        help="Optional output file path for MODIFIED conflicts list",
    )
    args = parser.parse_args()

    old_root = Path(args.old_dir).resolve()
    new_root = Path(args.new_dir).resolve()
    changes_path = Path(args.changes_file).resolve()

    if not old_root.exists() or not old_root.is_dir():
        raise SystemExit(f"old_dir does not exist or is not a directory: {old_root}")
    if not new_root.exists() or not new_root.is_dir():
        raise SystemExit(f"new_dir does not exist or is not a directory: {new_root}")
    if not changes_path.exists() or not changes_path.is_file():
        raise SystemExit(f"changes_file does not exist or is not a file: {changes_path}")

    include_extensions = None
    if args.extensions:
        include_extensions = {ext.lower().lstrip(".") for ext in args.extensions}

    apply_added = not args.only_delete and not args.only_modified
    apply_modified = not args.only_add and not args.only_delete
    apply_deleted = not args.only_add and not args.only_modified

    apply_changes(
        old_root,
        new_root,
        changes_path,
        include_extensions,
        apply_added,
        apply_modified,
        apply_deleted,
        args.add_include,
        args.add_exclude,
        args.delete_include,
        args.delete_exclude,
        Path(args.conflicts_out).resolve() if args.conflicts_out else None,
    )
    print("Changes were applied successfully.")


if __name__ == "__main__":
    main()
